### **Technical Specification for AI-Powered Data Structuring Application**

---

### **Tech Stack Overview:**

#### **1. Frontend**
- **Framework**: React.js (Next.js for SSR and routing).
- **Styling**: Tailwind CSS with ShadCN UI components.
- **State Management**: React Context/Redux for state.

#### **2. Backend**
- **Serverless Functions**: Vercel (for lightweight backend tasks).
- **Database**: Optional (can be deferred to future versions). Temporary storage handled by browser session/local storage and cookies.

#### **3. AI Models**
- **OpenAI**: GPT-4o-Mini.
- **Anthropic**: Claude 3.5-Haiku.
- **Google**: Gemini 2 Flash.

#### **4. Deployment**
- **Platform**: Vercel (frontend and backend).

#### **5. Libraries and Tools**
- **File Handling**: `react-dropzone` (drag-and-drop file upload).
- **JSON Manipulation**: `ajv` (JSON validation) and `jsoneditor` (preview and editing).
- **AI Communication**: OpenAI, Anthropic, and Google Gemini SDKs/APIs.
- **Markdown Parsing**: `remark`, `unified`.
- **Payments**: Stripe SDK for monetisation.

---

### **1. Input Handling**

#### **Frontend**

**Drag-and-Drop File Input:**
- Use `react-dropzone` for a modern drag-and-drop interface with multi-file support.

**Code Example:**
```javascript
import { useDropzone } from 'react-dropzone';

const FileUpload = ({ onFilesUploaded }) => {
    const onDrop = (acceptedFiles) => {
        onFilesUploaded(acceptedFiles);
    };

    const { getRootProps, getInputProps } = useDropzone({
        onDrop,
        accept: ['.txt', '.csv', '.pdf', '.docx', '.xlsx']
    });

    return (
        <div {...getRootProps()} className="border-dashed border-2 p-6">
            <input {...getInputProps()} />
            <p>Drag and drop files here, or click to select files</p>
        </div>
    );
};
export default FileUpload;
```

**File Parsing:**
- Use libraries like `papaparse` (CSV), `mammoth.js` (DOC), `pdf-lib` (PDF), and `sheetjs` (Excel).

**Example for CSV Parsing:**
```javascript
import Papa from 'papaparse';

const parseCSV = (file) => {
    return new Promise((resolve, reject) => {
        Papa.parse(file, {
            header: true,
            complete: (results) => resolve(results.data),
            error: (error) => reject(error)
        });
    });
};
```

#### **Batch Processing**
- Enable queuing and progress indicators for multiple files.

---

### **2. AI Processing Pipeline**

#### **Pipeline Overview**

1. **Preprocessing:**
   - Clean input data (remove special characters, unnecessary formatting).

2. **AI API Calls:**
   - Allow model selection and secure API key input (stored in cookies/session).

3. **Post-Processing:**
   - Validate AI-generated JSON with `ajv`.

**Serverless Function Example (Vercel):**
```javascript
import { Configuration, OpenAIApi } from 'openai';

export default async function handler(req, res) {
    const { apiKey, model, inputData } = req.body;

    const openai = new OpenAIApi(new Configuration({ apiKey }));

    try {
        const response = await openai.createChatCompletion({
            model,
            messages: [
                { role: 'system', content: 'You are a JSON structuring assistant.' },
                { role: 'user', content: inputData }
            ]
        });

        res.status(200).json(response.data.choices[0].message.content);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
}
```

#### **Session Management**
- Use `js-cookie` to securely store user API keys.

**Example:**
```javascript
import Cookies from 'js-cookie';

const saveApiKey = (key) => Cookies.set('apiKey', key, { secure: true, sameSite: 'Strict' });
const getApiKey = () => Cookies.get('apiKey');
```

---

### **3. JSON Output Specifications**

#### **Features**
- **Indentation and Prettification:** Use `JSON.stringify(data, null, 2)`.
- **Validation:** Ensure correctness with `ajv`.

**Real-Time Preview and Editing:**
- Use `jsoneditor` for interactive editing.

**Example Code:**
```javascript
import { JsonEditor } from 'jsoneditor-react';
import 'jsoneditor-react/es/editor.min.css';

const JSONPreview = ({ jsonData, onChange }) => {
    return (
        <JsonEditor
            value={jsonData}
            onChange={onChange}
            mode="tree"
            allowedModes={['tree', 'code']}
        />
    );
};
export default JSONPreview;
```

#### **Export Options**
- Raw JSON, JSONL, Prettified JSON.

**Example for Downloading JSON:**
```javascript
const downloadJSON = (data) => {
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'data.json';
    a.click();
};
```

---

### **4. User Interface Design**

#### **Dashboard Layout**
- **Input Section**: Drag-and-drop area, file list, and manual input box.
- **AI Model Selection**: Dropdown for model selection and API key input.
- **JSON Preview**: Dynamic JSON preview and editor.
- **Schema Templates**: Sidebar for schema management.

---

### **5. Stripe Integration**

#### **Client-Side Integration**
- Use Stripe Checkout for payment.

**Example Code:**
```javascript
import { loadStripe } from '@stripe/stripe-js';

const stripePromise = loadStripe('your-publishable-key');

const handleCheckout = async () => {
    const stripe = await stripePromise;
    const response = await fetch('/api/checkout-session', { method: 'POST' });
    const session = await response.json();

    stripe.redirectToCheckout({ sessionId: session.id });
};
```

#### **Serverless Function for Stripe Checkout**
```javascript
import Stripe from 'stripe';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);

export default async function handler(req, res) {
    const session = await stripe.checkout.sessions.create({
        payment_method_types: ['card'],
        line_items: [
            { price: 'price_xxx', quantity: 1 } // Replace with your product price ID
        ],
        mode: 'payment',
        success_url: `${req.headers.origin}/success`,
        cancel_url: `${req.headers.origin}/cancel`
    });

    res.status(200).json({ id: session.id });
}
```

---

### **6. Implementation Roadmap**

#### **Milestone 1**: Basic Input Handling
- Implement file drag-and-drop, parsing, and text input.

#### **Milestone 2**: AI Integration
- Connect GPT-4o-mini, Claude 3.5-Haiku, and Gemini 2 Flash APIs.
- Add model selection and API key management.

#### **Milestone 3**: JSON Generation
- Develop JSON formatting and validation pipeline.

#### **Milestone 4**: UI Development
- Build the dashboard with real-time preview, schema tools, and file management.

#### **Milestone 5**: Deployment
- Deploy on Vercel and test functionality.

---

### **7. Future Enhancements**

#### **1. User Authentication and Schema Versioning**
**Objective**: Enable user accounts for enhanced functionality and allow users to track schema changes over time.

**Features:**
- **Secure Login and Registration:**
  - Implement authentication using Supabase Auth with support for email/password and social logins (Google, GitHub).
  - Store user credentials securely with JWT tokens.

**Implementation Details:**
- Add a dedicated authentication module in the frontend.
- Use Supabase’s Auth API for backend integration.

**Schema Versioning:**
- Allow users to save, retrieve, and track schema versions.
- Use Supabase’s database to store user-specific schemas and version history.
- Enable rollback functionality for schema changes.

---

#### **2. Collaboration Features**
**Objective**: Support real-time collaboration and sharing of JSON schemas among users.

**Features:**
- **Shared Schemas:**
  - Users can create public or private schemas.
  - Share schemas via unique links with edit/view permissions.

**Implementation Details:**
- Use a collaborative database structure in Supabase.
- Include role-based access control (RBAC) for schema permissions.
- Integrate with WebSockets or Supabase’s real-time functionality for live updates.

**Live Collaboration:**
- Allow multiple users to work on a schema simultaneously.
- Integrate `y.js` or similar collaborative libraries to handle real-time updates.

---

#### **3. Enhanced AI Features**
**Objective**: Improve AI functionality and expand its use cases.

**Features:**
- **Custom AI Prompts:**
  - Let users create and save custom prompts for specific JSON structures.

- **Multi-Model Analysis:**
  - Compare results from multiple AI models (e.g., GPT-4, Claude, Gemini) side-by-side.
  - Offer detailed insights into model behaviour.

**Implementation Details:**
- Expand the serverless API functions to handle multi-model requests.
- Use advanced prompting techniques to optimise AI outputs.

---

#### **4. Advanced Export and Integration Options**
**Objective**: Support more export formats and external integrations.

**Features:**
- **Export Options:**
  - Add support for YAML, XML, and database-ready formats (e.g., SQL dumps).
- **Third-Party Integrations:**
  - Directly push JSON output to cloud platforms (AWS S3, Firebase) or APIs.

**Implementation Details:**
- Use libraries like `js-yaml` for YAML conversion and custom parsers for XML.
- Build integration modules for cloud APIs with OAuth support.

---

#### **5. Analytics and Reporting**
**Objective**: Provide users with detailed insights into their data and AI usage.

**Features:**
- **Usage Statistics:**
  - Show the number of processed files, API calls, and JSON structures generated.
- **AI Performance Metrics:**
  - Display AI accuracy and response times.

**Implementation Details:**
- Collect anonymised usage data and store it in Supabase.
- Visualise metrics using chart libraries like Chart.js or D3.js.

---

#### **6. Monetisation and Subscription Plans**
**Objective**: Implement advanced payment tiers for additional services.

**Features:**
- **Subscription Plans:**
  - Introduce tiered plans (Free, Pro, Enterprise).
  - Pro users get higher limits, premium support, and custom AI usage.

**Implementation Details:**
- Use Stripe’s subscription API.
- Offer in-app notifications for plan upgrades and renewals.

---

#### **7. Mobile Application Support**
**Objective**: Expand functionality to mobile devices for broader accessibility.

**Features:**
- **Cross-Platform Support:**
  - Build a mobile-first version using React Native.
  - Sync schemas and preferences across devices.

**Implementation Details:**
- Leverage Supabase’s real-time capabilities to sync data.
- Use device storage for offline mode.

---

#### **8. AI Model Hosting and Proxying**
**Objective**: Allow users to bypass API key management for seamless AI interactions.

**Features:**
- Host AI model calls via backend server (e.g., Vercel functions).
- Implement rate-limiting and usage tracking for hosted models.

**Implementation Details:**
- Proxy requests through a secure backend function.
- Monitor API usage and enforce limits based on user plans.

---

#### **9. Offline Mode**
**Objective**: Allow users to process files and work on schemas without internet connectivity.

**Features:**
- Provide offline JSON editing and schema creation capabilities.
- Cache AI-generated suggestions for reuse.

**Implementation Details:**
- Use `IndexedDB` or `localForage` to store schemas locally.
- Sync offline changes to the cloud when reconnected.

---

These enhancements aim to increase the application’s functionality, usability, and scalability, ensuring it meets the evolving needs of users.

